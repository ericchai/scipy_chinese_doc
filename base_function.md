## 基本功能

### 与numpy互动
scipy建立在numpy之上，而对于所有基本的数组处理需求，你可以使用numpy函数：

```python
>>> import numpy as np
>>> np.some_function()
```
每个函数的详细说明可使用help,info和source命令查看。要使用某些scipy模块的功能，你可以这样做：

```python
>>> from scipy import some_module
>>> some_module.some_function()
```
顶级scipy还包含来自numpy和numpy.lib.scimath，但是最好直接从numpy模块使用它们。

#### 索引技巧
有一些类实例特别使用了切片功能来为数组构建提供有效手段。这部分将讨论的操作np.mgrid，np.ogrid， np.r\_，和np.c\_快速构建阵列。

例如：

```python
>>> a = np.concatenate(([3], [0]*5, np.arange(-1, 1.002, 2/9.0)))
```
这也可以通过r\_命令得到同样的结果

```python
>>> a = np.r_[3,[0]*5,-1:1:10j]
```
这可以减轻打字的负担并提高代码的可读性。注意如何连接对象，并使用分割语法（ab）来构造范围。另一个值得解释的术语是使用复数10j作为切片语​​法中的步长。这种非标准使用允许将数字解释为在范围内产生的点数，而不是步长（注意，我们将使用长整数表示法10L，但是这种表示法可能会在Python中消失，因为整数变得统一）。这种非标准的用法对某些人来说可能不太好看，但它使用户能够以非常可读的方式快速构建复杂的矢量。当以这种方式指定点数时，终点是包容性的。

“r”代表行连接，因为如果逗号之间的对象是2维数组，则它们按行堆叠（因此必须具有相称的列）。有一个等效命令c\_可以按列堆叠2d个数组，但其功能与r\_1d数组完全相同 。

另一个非常有用的使用扩展切片符号的类实例是该函数*mgrid*。在最简单的情况下，这个函数可以用来构造1d范围作为arange的方便替代。它还允许使用步长中的复数来指示放置在（包含）端点之间的点数。然而，该功能的真正目的是产生提供N维体积坐标阵列的N，Nd阵列。理解这个最简单的方法是用它的一个例子：

```python
>>> np.mgrid[0:5,0:5]
array([[[0, 0, 0, 0, 0],
        [1, 1, 1, 1, 1],
        [2, 2, 2, 2, 2],
        [3, 3, 3, 3, 3],
        [4, 4, 4, 4, 4]],
       [[0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4]]])
>>> np.mgrid[0:5:4j,0:5:4j]
array([[[ 0.    ,  0.    ,  0.    ,  0.    ],
        [ 1.6667,  1.6667,  1.6667,  1.6667],
        [ 3.3333,  3.3333,  3.3333,  3.3333],
        [ 5.    ,  5.    ,  5.    ,  5.    ]],
       [[ 0.    ,  1.6667,  3.3333,  5.    ],
        [ 0.    ,  1.6667,  3.3333,  5.    ],
        [ 0.    ,  1.6667,  3.3333,  5.    ],
        [ 0.    ,  1.6667,  3.3333,  5.    ]]])

```
像这样的网格化数组有时非常有用。然而，由于Numpy和SciPy的阵列广播规则，并不总是只需要评估网格上的一些N维函数。如果这是生成meshgrid的唯一目的，则应改为使用ogrid生成“open”网格的函数，以newaxis明智地创建N，Nd数组，其中每个数组中只有一个维度的长度大于1。这将节省内存并且如果*meshgrid*的唯一目的是生成用于评估Nd函数的采样点，则创建相同的结果。

#### 形状操作

在这类函数中，用于缩小长度的例程 - 从N维数组中取出一个维度，确保数组至少为1维，2维或3维，并按行，列和数组堆叠（连接）数组“页面”（在第三维中）。分割数组的例程（大致与堆栈数组相反）也可用。

#### 多项式

处理SciPy中的一维多项式有两种（可互换的）方法。首先是使用Numpy中的poly1d，这个类接受系数或多项式根来初始化一个多项式。然后可以在代数表达式中对多项式对象进行操作，进行集成，区分和评估。它甚至可以像多项式一样打印：

```python
>>> from numpy import poly1d
>>> p = poly1d([3,4,5])
>>> print(p)
   2
3 x + 4 x + 5
>>> print(p*p)
   4      3      2
9 x + 24 x + 46 x + 40 x + 25
>>> print(p.integ(k=6))
   3     2
1 x + 2 x + 5 x + 6
>>> print(p.deriv())  # 求导
6 x + 4
>>> p([4, 5])         # 计算实际的值
array([ 69, 100])
```
处理多项式的另一种方式是将系数阵列与阵列的第一个元素给出最高功率的系数。有显式的函数来加，减，乘，除，积分，微分和计算表示为系数序列的多项式。


#### 向量化函数(向量化)

NumPy提供的一个功能是vectorize将一个普通的Python函数转换为一个“矢量化函数”，该函数接受标量和返回标量，并使用与其他Numpy函数（即通用函数或ufuncs）相同的广播规则。例如，假设您有一个名为addsubtractdefined 的Python函数 ：

```python
>>> def addsubtract(a,b):
...    if a > b:
...        return a - b
...    else:
...        return a + b
```
它定义了两个标量变量的函数并返回一个标量结果。类vectorize可以用来“矢量化”这个函数:

```python
>>> vec_addsubtract = np.vectorize(addsubtract)
```
返回一个接受数组参数并返回数组结果的函数：

```python
>>> vec_addsubtract([0,3,6,9],[1,3,5,7])
array([1, 6, 1, 2])
```
这个特殊的功能可以用矢量形式编写而不需要使用vectorize。但是，使用优化或集成例程的函数可能只能使用矢量化vectorize.

#### 类型处理
请注意np.iscomplex/np.isreal和np.iscomplexobj/np.isrealobj之间的区别。前一个命令是基于数组的，并返回1和0的字节数组，提供元素测试的结果。后者命令是基于对象的，并返回描述整个对象测试结果的标量。

通常需要得到复数的实部和/或虚部。虽然复数和数组具有返回这些值的属性，但如果不确定对象是否具有复数值，最好使用函数形式 np.real和np.imag。这些函数对于任何可以变成Numpy数组的东西都是成功的。还考虑将np.real_if_close具有微小虚部的复数值转换为实数的函数。
偶尔需要检查一个数字是否是一个标量（Python（long）int，Python float，Python complex或0级数组）。这个功能在np.isscalar返回1或0 的方便函数中提供。

最后，确保对象是特定的Numpy类型通常足以使它通过使用np.cast字典在SciPy中被赋予一个方便的接口。字典的键入方式是希望转换为类型，字典存储函数来执行转换。因此，np.cast\['f'\](d)返回np.float32来自d的一个数组。这个函数作为获取某种类型标量的简单方法也很有用：

```python
>>> np.cast['f'](np.pi)
array(3.1415927410125732, dtype=float32)
```
#### 其他有用的功能

还有几个其他应该提及的有用功能。为了这样做相位处理，则这些功能angle，并且unwrap是有用的。另外，函数linspace和 logspace函数以线性或对数比例返回等间隔采样。最后，了解Numpy的索引功能很有用。应该提到 select扩展功能where以包括多种条件和多种选择的功能。调用约定是select(condlist,choicelist,default=0). select 多个if语句的矢量化形式。它允许快速构建一个函数，该函数返回基于条件列表的结果数组。返回数组的每个元素都从数组中取出，choicelist对应于第一个条件 condlist那是真实的。例如：

```python
>>> x = np.r_[-2:3]
>>> x
array([-2, -1,  0,  1,  2])
>>> np.select([x > 3, x >= 0], [0, x+2])
array([0, 0, 2, 3, 4])
```
模块中还可以找到一些其他有用的功能 scipy.misc。例如factorial和comb 函数计算 $ n!$和$n!/k!(n-k)!$使用精确的整数运算（感谢Python的Long整型对象），或者使用浮点精度和伽马函数。另一个函数返回一个用于图像处理的公共图像：lena。

最后，提供了两个函数，它们用于使用离散差分来近似函数的导数。该函数 central_diff_weights返回等间距的加权系数点o近似于阶数o的导数。这些权重必须乘以与这些点相对应的函数，并将结果相加以获得导数近似值。此功能仅适用于仅有功能样品可用的情况。当函数是一个可以交给例程并进行derivative评估的对象时，函数 可以用来在正确的点处自动评估对象，以获得给定点处的o阶导数的N点近似值。

